---
title: "Excluderanges processing"
author: "Mikhail Dozmorov"
date: "`r Sys.Date()`"
output:
  pdf_document:
    toc: no
  html_document:
    theme: cerulean
    toc: yes
---

```{r setup, echo=FALSE, message=FALSE, warning=FALSE}
# Set up the environment
library(knitr)
opts_chunk$set(cache.path='cache/', fig.path='img/', cache=F, tidy=T, fig.keep='high', echo=F, dpi=100, warnings=F, message=F, comment=NA, warning=F, results='as.is', fig.width = 10, fig.height = 6) #out.width=700, 
library(pander)
panderOptions('table.split.table', Inf)
set.seed(1)
```

# Libraries

```{r libraries}
library(tidyverse)
library(readxl)
library(writexl)
library(cowplot)
library(stringr)
library("ggsci")
library(scales)
# scales::show_col(pal_lancet("lanonc")(8))
mycols = pal_lancet("lanonc")(8)
# Color palette for the heatmap, https://www.nceas.ucsb.edu/~frazier/RSpatialGuides/colorPaletteCheatsheet.pdf
col3 <- colorRampPalette(c('blue', 'white', 'red'))(20)
# col3 <- colorRampPalette(c('blue', 'gray', 'yellow'))(20)
# col3 <- colorRampPalette(c('green', 'black', 'red'))(20)
# col3 <- colorRamps::green2red(n = 20)
library(GenomicRanges)
library(rtracklayer)
```

# Settings

```{r settings}
# Project folder path
dir_data <- "/Users/mdozmorov/Documents/Work/GitHub/excluderanges.dev/Mikhail"
# Results folder, create if not exist
dir_results <- file.path(dir_data, "excludableSets_bed")
if (!dir.exists(dir_results)) dir.create(dir_results)
# Create subdirs for specific results
if (!dir.exists(file.path(dir_results, "bed"))) dir.create(file.path(dir_results, "bed"))
if (!dir.exists(file.path(dir_results, "rds"))) dir.create(file.path(dir_results, "rds"))
# Summary table
fileNameOutSummary <- file.path(dir_results, "summary.csv")
# Increade download file timeout 
# https://stackoverflow.com/questions/35282928/how-do-i-set-a-timeout-for-utilsdownload-file-in-r
options(timeout=100)
```

# Create a table

```{r}
# Manually created matrix with information for download
mtx <- rbind(
             ### HUMAN excludable sets
             c("T2T.excluderanges", "T2T", "Defined by the Boyle-Lab/Blacklist software, High Signal and Low Mappability regions", "2022", "excluderanges", "excluderanges"), # checked
             c("hg38.Kundaje.GRCh38_unified_blacklist", "hg38", "Defined as a combination of hg38.Lareau.hg38_peaks, hg38.Boyle.hg38-blacklist.v2, and hg38.Wimberley.peakPass60Perc_sorted, followed by manual curation. Supersedes hg38.Kundaje.GRCh38.blacklist.", "2020", "ENCODE", "ENCFF356LFX"), # checked, Kundaje-unified, ENCFF356LFX, added 2020-05-05. checked twice.
             c("hg38.Bernstein.Mint_Blacklist_GRCh38", "hg38", "Defined from Mint-ChIP (low input, multiplexed ChIP-seq) data", "2019", "ENCODE", "ENCFF023CZC"), # checked -- Bernstein, ENCFF023CZC, added 2019-07-22. checked twice.
             c("hg38.Boyle.hg38-blacklist.v2", "hg38", "Defined by the Boyle-Lab/Blacklist software, High Signal and Low Mappability regions", "2018", "GitHub", "https://github.com/Boyle-Lab/Blacklist/raw/master/lists/hg38-blacklist.v2.bed.gz"), # checked -- Boyle, commit Nov 13, 2018. checked twice.
             c("hg38.Kundaje.GRCh38.blacklist", "hg38", "Defined by Anshul Kundaje as a part of ENCODE and modENCODE consortia", "2016", "ENCODE", "ENCFF419RSJ"), # checked, Kundaje, ENCFF419RSJ, added 2016-10-16. checked twice.
             c("hg38.Lareau.hg38.full.blacklist", "hg38", "ENCODE excludable regions combined with regions of high homology to mtDNA (NUMT regions)", "2017", "GitHub", "https://github.com/caleblareau/mitoblacklist/raw/master/combinedBlacklist/hg38.full.blacklist.bed"), # checked -- Lareau-full, commit May 29, 2017. checked twice.
             c("hg38.Reddy.wgEncodeDacMapabilityConsensusExcludable.hg38", "hg38", "Defined by the ENCODE consortium, includes satellite repeats (CATTC, GAATG, GAGTG, ACRO1), RepeatMasker repeats (ALR/Alpha, BSR/Beta), centromeric repeats, chrM, High/Low mappability islands", "2016", "ENCODE", "ENCFF220FIN"), # checked -- Reddy, ENCFF220FIN, added 2016-03-11. checked twice.
             c("hg38.Wimberley.peakPass60Perc_sorted", "hg38", "Defined by the ewimberley/peakPass software", "2021", "GitHub", "https://github.com/ewimberley/peakPass/raw/main/excludedlists/hg38/peakPass60Perc_sorted.bed"), # checked -- Wimberley, peakpass, hg38, commit Feb 11, 2021. checked twice
             c("hg38.Wold.hg38mitoblack", "hg38", "Definition method unknown", "2016", "ENCODE", "ENCFF940NTE"), # checked -- Wold, ENCFF940NTE, added 2016-04-21. checked twice.
             c("hg38.Yeo.eCLIP_blacklistregions.hg38liftover.bed.fixed", "hg38", "Defined from eCLIP data", "2019", "ENCODE", "ENCFF269URO"), # checked -- Yeo, ENCFF269URO, added 2019-11-08. checked twice.
             c("hg19.Boyle.hg19-blacklist.v2", "hg19", "Defined by the Boyle-Lab/Blacklist software, High Signal and Low Mappability regions", "2018", "GitHub", "https://github.com/Boyle-Lab/Blacklist/blob/master/lists/hg19-blacklist.v2.bed.gz?raw=true"), # checked -- Boyle, commit Nov 13, 2018. checked twice.
             c("hg19.Bernstein.Mint_Blacklist_hg19", "hg19", "Defined from Mint-ChIP (low input, multiplexed ChIP-seq) data", "2019", "ENCODE", "ENCFF200UUD"), # checked-- Bernstein, ENCFF200UUD, added 2019-07-22. checked twice.
             c("hg19.Birney.wgEncodeDacMapabilityConsensusExcludable", "hg19","Defined by the ENCODE consortium, includes satellite repeats (CATTC, GAATG, GAGTG, ACRO1), RepeatMasker repeats (ALR/Alpha, BSR/Beta), centromeric repeats, chrM, High/Low mappability islands", "2011", "ENCODE", "ENCFF001TDO"), # checked -- Birney, ENCFF001TDO, added 2011-05-04. checked twice.
             c("hg19.Crawford.wgEncodeDukeMapabilityRegionsExcludable", "hg19", "Defined by the ENCODE consortium, includes satellite repeats (CATTC, GAATG, GAGTG, ACRO1), RepeatMasker repeats (ALR/Alpha, BSR/Beta), human satellite repeat HSATII, chrM, ribosomal subunit consensus sequences LSU-rRNA_Hsa, SSU-rRNA_Hsa", "2011", "ENCODE", "ENCFF001THR"), # checked -- Crawford, ENCFF001THR, added 2011-03-28. checked twice.
             c("hg19.Lareau.hg19.full.blacklist", "hg19", "ENCODE excludable regions combined with regions of high homology to mtDNA (NUMT regions)", "2017", "GitHub", "https://github.com/caleblareau/mitoblacklist/raw/master/combinedBlacklist/hg19.full.blacklist.bed"), # checked -- Lareau-full, commit May 29, 2017. checked twice.
             c("hg19.Wold.hg19mitoblack", "hg19", "Definition method unknown", "2016", "ENCODE", "ENCFF055QTV"), # checked -- Wold, ENCFF055QTV, added 2016-04-21. checked twice.
             c("hg19.Yeo.eCLIP_blacklistregions.hg19", "hg19", "Defined from eCLIP data, includes skyscraper, rRNA pseudogene, unreliably mapped satellite repeat, and low complexity skyscraper peak regions", "2019", "ENCODE", "ENCFF039QTN"), # checked -- Yeo, ENCFF039QTN, added 2019-11-08. checked twice.

             ### MOUSE excludable sets
             c("mm39.excluderanges", "mm39", "Defined by the Boyle-Lab/Blacklist software, High Signal and Low Mappability regions", "2022", "excluderanges", "excluderanges"), # checked
             c("mm10.Boyle.mm10-blacklist.v2", "mm10", "Defined by the Boyle-Lab/Blacklist software, High Signal and Low Mappability regions", "2018", "GitHub", "https://github.com/Boyle-Lab/Blacklist/raw/master/lists/mm10-blacklist.v2.bed.gz"), # checked -- Boyle, mm10, commit Nov 19, 2018. checked twice.
             c("mm10.Hardison.blacklist.full", "mm10", "Definition method unknown", "2016", "ENCODE", "ENCFF790DJT"), # checked -- Hardison, ENCFF790DJT, added 2016-03-28. checked twice.

             c("mm10.Hardison.psublacklist.mm10", "mm10", "Definition method unknown", "2016", "ENCODE", "ENCFF226BDM"), # checked -- Hardison, ENCFF226BDM, added 2016-03-28. checked twice.
             c("mm10.Kundaje.anshul.blacklist.mm10", "mm10", "Defined by Anshul Kundaje as a part of ENCODE and modENCODE consortia", "2016", "ENCODE", "ENCFF999QPV"), # checked -- Kundaje, ENCFF999QPV, added 2016-03-28. checked twice.
             c("mm10.Kundaje.mm10.blacklist", "mm10", "Defined by Anshul Kundaje as a part of ENCODE and modENCODE consortia", "2016", "ENCODE", "ENCFF547MET"), # checked -- Kundaje, ENCFF547MET, added 2016-10-16. checked twice.
             c("mm10.Lareau.mm10.full.blacklist", "mm10", "ENCODE excludable regions combined with regions of high homology to mtDNA (NUMT regions)", "2017", "GitHub", "https://github.com/caleblareau/mitoblacklist/raw/master/combinedBlacklist/mm10.full.blacklist.bed"), # checked -- Lareau-full mm10, commit May 29, 2017. checked twice.
             c("mm10.Wold.mm10mitoblack", "mm10", "Definition method unknown", "2016", "ENCODE", "ENCFF759PJK"), # checked -- Wold, ENCFF759PJK, added 2016-04-21. checked twice.
             c("mm9.Lareau.mm9.full.blacklist", "mm9", "ENCODE excludable regions combined with regions of high homology to mtDNA (NUMT regions)", "2017", "GitHub", "https://github.com/caleblareau/mitoblacklist/raw/master/combinedBlacklist/mm9.full.blacklist.bed"), # checked -- Lareau-full mm9, commit May 29, 2017. checked twice.
             c("mm9.Wold.mm9mitoblack", "mm9", "Definition method unknown", "2016", "ENCODE", "ENCFF299EZH"), # checked -- Wold, ENCFF299EZH, add 2016-04-21. checked twice.
 
             ### WORM excludable sets
             c("ce11.Boyle.ce11-blacklist.v2", "ce11", "Defined by the Boyle-Lab/Blacklist software, High Signal and Low Mappability regions", "2018", "GitHub", "https://github.com/Boyle-Lab/Blacklist/raw/master/lists/ce11-blacklist.v2.bed.gz"), # checked -- Boyle ce11, commit Nov 19, 2018. checked twice.
             c("ce10.Boyle.ce10-blacklist.v2", "ce10", "Defined by the Boyle-Lab/Blacklist software, High Signal and Low Mappability regions", "2018", "GitHub", "https://github.com/Boyle-Lab/Blacklist/raw/master/lists/ce10-blacklist.v2.bed.gz"), # checked -- Boyle ce10, commit Nov 19, 2018. checked twice.
             c("ce10.Kundaje.ce10-blacklist", "ce10", "Defined by Anshul Kundaje, superseded by ce10.Boyle.ce10-blacklist.v2", "2012", "Stanford.edu", "http://mitra.stanford.edu/kundaje/akundaje/release/blacklists/ce10-C.elegans/ce10-blacklist.bed.gz"), # checked, Kundaje ce10, last modified 2012-11-13. checked twice.
             
             ### ZEBRAFISH excludable sets
             c("danRer10.Domingues.blacklisted", "danRer10", "Defined manually using total RNA-seq.", "2020", "GitHub", "https://github.com/adomingues/redl_domingues_et_al_dev_2020/raw/main/blacklisted.bed"), # checked -- Domingues danRer10, commit Dec 27, 2020. checked twice.
             c("danRer10.Yang.Supplemental_Table_19.ChIP-seq_black_list_in_the_zebrafish_genome", "danRer10", "Defined via MACS2 peak calling using ChIP-seq (PMID: 33239788)", "2020", "Publication", "https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8183574/bin/NIHMS1695157-supplement-Supplementary_Table_1-19.zip"), # checked -- published 2020 Nov 25. checked twice.
 
             ### FLY excludable sets
             c("dm6.Boyle.dm6-blacklist.v2", "dm6", "Defined by the Boyle-Lab/Blacklist software, High Signal and Low Mappability regions", "2018", "GitHub", "https://github.com/Boyle-Lab/Blacklist/raw/master/lists/dm6-blacklist.v2.bed.gz"), # checked -- Boyle dm6, commit Nov 19, 2018. checked twice.
             c("dm3.Boyle.dm3-blacklist.v2", "dm3", "Defined by the Boyle-Lab/Blacklist software, High Signal and Low Mappability regions", "2018", "GitHub", "https://github.com/Boyle-Lab/Blacklist/raw/master/lists/dm3-blacklist.v2.bed.gz"), # checked -- Boyle dm3, commit Nov 19, 2018. checked twice.
             c("dm3.Kundaje.dm3-blacklist", "dm3", "Defined by Anshul Kundaje, superseded by dm3.Boyle.dm3-blacklist.v2", "2012", "Stanford.edu", "http://mitra.stanford.edu/kundaje/akundaje/release/blacklists/dm3-D.melanogaster/dm3-blacklist.bed.gz"), # checked -- Kundaje, dm3, last modified 2012-11-20. checked twice.
 
             ### PLANT excludable sets
             c("TAIR10.Wimberley.predicted_excluded_list_sorted_0.6", "TAIR10", "Defined by the ewimberley/peakPass software", "2021", "GitHub", "https://github.com/ewimberley/peakPass/raw/main/excludedlists/tair10/predicted_excluded_list_sorted_0.6.bed"), # checked, Wimberley peakpass TAIR10, commit Feb 11, 2021. checked twice.
             c("TAIR10.Klasfeld.arabidopsis_blacklist_20inputs", "TAIR10", "Defined by the Boyle-Lab/Blacklist software, High Signal and Low Mappability regions (DOI: 10.1101/2022.02.27.482177)", "2021", "GitHub", "https://github.com/sklasfeld/GreenscreenProject/raw/main/data/arabidopsis_blacklist_20inputs.bed"), # checked, Klasfeld TAIR10 Blacklist, commit Apr 29, 2021. checked twice.
             c("TAIR10.Klasfeld.arabidopsis_greenscreen_20inputs", "TAIR10", "Defined by the green screen pipeline (DOI: 10.1101/2022.02.27.482177)", "2021", "GitHub", "https://github.com/sklasfeld/GreenscreenProject/raw/main/data/arabidopsis_greenscreen_20inputs.bed"), # checked, Klasfeld TAIR10 Greenscreen, commit Apr 29, 2021. checked twice.
             
             ### HUMAN NUMT sets
             c("T2T.Lareau.chm13v2.0_peaks", "T2T", "Regions of high homology to mtDNA (NUMT regions) defined by caleblareau/mitoblacklist", "2022", "GitHub", "https://github.com/caleblareau/mitoblacklist/raw/master/peaks/chm13v2.0_peaks.narrowPeak"), # checked -- Lareau-peaks, commit Jun 10 [2022]. checked twice.
             c("hg38.Lareau.hg38_peaks", "hg38", "Regions of high homology to mtDNA (NUMT regions) defined by caleblareau/mitoblacklist", "2017", "GitHub", "https://github.com/caleblareau/mitoblacklist/raw/master/peaks/hg38_peaks.narrowPeak"), # checked -- Lareau-peaks, commit Apr 24, 2017. checked twice.
             c("hg19.Lareau.hg19_peaks", "hg19", "Regions of high homology to mtDNA (NUMT regions) defined by caleblareau/mitoblacklist", "2017", "GitHub", "https://github.com/caleblareau/mitoblacklist/raw/master/peaks/hg19_peaks.narrowPeak"), # checked -- Lareau-peaks, commit Apr 24, 2017. checked twice.
             
             ### MOUSE NUMT sets
             c("mm10.Lareau.mm10_peaks", "mm10", "Regions of high homology to mtDNA (NUMT regions) defined by caleblareau/mitoblacklist", "2017", "GitHub", "https://github.com/caleblareau/mitoblacklist/raw/master/peaks/mm10_peaks.narrowPeak"), # checked -- Lareau-peaks, mm10, commit Apr 24, 2017. checked twice
             c("mm9.Lareau.mm9_peaks", "mm9", "Regions of high homology to mtDNA (NUMT regions) defined by caleblareau/mitoblacklist", "2017", "GitHub", "https://github.com/caleblareau/mitoblacklist/raw/master/peaks/mm9_peaks.narrowPeak") # checked -- Lareau-peaks, mm9, commit Apr 24, 2017. checked twice.
             )
# Make data frame
mtx <- as.data.frame(mtx)
# Assign column names
colnames(mtx) <- c("Name", "Assembly", "Description", "Year last updated", "Source", "ID/URL")
```

# Excluderanges

```{r data}
# Vectors to store summary information
# Number of original regions
counts_original <- numeric(length = nrow(mtx))
# Number of keepStandardChromosomes regions
counts_standard <- numeric(length = nrow(mtx))
# Chromosomes that are missing from the list
chromosomes_missing <- character(length = nrow(mtx))
url_formatted <- character(length = nrow(mtx))
# Width statistics
width_min <- numeric(length = nrow(mtx))
width_median <- numeric(length = nrow(mtx))
width_max <- numeric(length = nrow(mtx))
# Percent of genome covered
fraction_genome <- numeric(length = nrow(mtx))

for (i in 1:nrow(mtx)) {
  # Process each record
  print(paste("Processing", i, mtx$Name[i]))
  # If source is ENCODE, construct URL
  if (mtx$Source[i] == "ENCODE") {
    URL <- paste0("https://www.encodeproject.org/files/", mtx$`ID/URL`[i], "/@@download/", mtx$`ID/URL`[i], ".bed.gz")
  } else {
    URL <- mtx$`ID/URL`[i]
  }
  # Keep formatted URL
  url_formatted[i] <- URL

  # Process only non-publication data. Publication data requires manual processing
  if (!(mtx$Source[i] %in% c("Publication", "excluderanges"))) {
    # Download output file name
    if (mtx$Source[i] == "ENCODE") {
      # ENCODE IDs need to have ".bed.gz" extension
      fileNameOut1 <- file.path(dir_results, paste0(mtx$Name[i], ".bed.gz"))
    } else {
      # Directly downloadable files have their own extension
      fileNameOut1 <- file.path(dir_results, paste0(mtx$Name[i], ".", tools::file_ext(mtx$`ID/URL`[i])))
    }
    # BED output file name
    fileNameOut2 <- file.path(dir_results, "bed", paste0(mtx$Name[i], ".bed"))
    # RDS output file name
    fileNameOut3 <- file.path(dir_results, "rds", paste0(mtx$Name[i], ".rds"))
    
    # Download file, if doesn't exist
    if (!file.exists(fileNameOut1)) download.file(URL, fileNameOut1)
    # Have a look inside
    mtx_data <- read_tsv(fileNameOut1, col_names = FALSE)
    print("Original data")
    print(head(mtx_data))
    # Save the number of original regions
    counts_original[i] <- nrow(mtx_data)

    # Read it into GenomicRanges object
    # Special provisions for selected files
    if (mtx$Name[i] == "T2T.Lareau.chm13v2.0_peaks") {
      # T2T.Lareau.chm13v2.0_peaks has spaces instead of tabs
      # Convert spaces to tabs in place
      system(paste0("awk -v OFS=\"\\t\" '$1=$1' ", fileNameOut1, " > tmp.bed"))
      system(paste0("mv tmp.bed ", fileNameOut1))
    }
    if (mtx$Assembly[i] == "TAIR10") {
      # TAIR10 chromosomes are capitalized, like "Chr1". Convert to lower case
      mtx_data <- read_tsv(file = fileNameOut1, col_names = FALSE)
      # Sometimes chromosomes are sjut numbers, append "chr"
      if (sum(grepl("chr", mtx_data$X1, ignore.case = TRUE)) == 0) {
        mtx_data$X1 <- paste0("chr", mtx_data$X1)
      }
      # Convert to lower case and save
      mtx_data$X1 <- tolower(mtx_data$X1)
      write_tsv(mtx_data, file = fileNameOut1, col_names = FALSE)
    }
    
    if (grepl("narrowPeak", mtx$`ID/URL`[i])) {
      # narrowPeak format
      extraCols_names <- c("numeric", "numeric", "numeric", "numeric")
      names(extraCols_names) <- c("signalValue", "pValue", "qValue", "peak")
      denyGR <- rtracklayer::import(con = fileNameOut1, format = "bed", extraCols = extraCols_names)
    } else if (mtx$Name[i] == "hg38.Yeo.eCLIP_blacklistregions.hg38liftover.bed.fixed") {
      # hg38.Yeo.eCLIP_blacklistregions.hg38liftover.bed.fixed has columns 4, 5, 6 as - - -
      extraCols_names <- c("character", "character", "character")
      names(extraCols_names) <- c("name1", "score1", "strand1")
      denyGR <- rtracklayer::import(con = fileNameOut1, format = "bed", extraCols = extraCols_names)
    } else {
      denyGR <- rtracklayer::import(con = fileNameOut1, format = "bed")
    }

    # Genome abbreviation
    genome_id <- mtx$Assembly[i]
    if (genome_id == "T2T") {
      # Seqinfo for T2T genome
      chrom_data <- GenomeInfoDb::getChromInfoFromNCBI(assembly = "T2T-CHM13v2.0", assembled.molecules.only = TRUE)
      chrom_data$AssignedMolecule <- as.character(paste0("chr", chrom_data$AssignedMolecule)) # GCA_009914755.4
      # Make the same format as UCSC chromosome data
      chrom_data <- data.frame(chrom = chrom_data$AssignedMolecule,
                               size = chrom_data$SequenceLength,
                               assembled = ifelse(chrom_data$AssemblyUnit == "Primary Assembly", TRUE, FALSE),
                               circular = chrom_data$circular)
      # Keep standard chromosomes
      chromosomes_standard <- chrom_data$chrom
      # Subset and match to chromosomes in the denyGR object
      # Common chromosomes
      chromosomes_common <- intersect(chrom_data$chrom, seqlevels(denyGR))
      # Subset denyGR
      denyGR <- keepSeqlevels(denyGR, chromosomes_common, pruning.mode = "tidy")      
      # Subset chrom_data
      chrom_data <- chrom_data[chrom_data$chrom %in% chromosomes_common, ]
      # Match objects
      chrom_data <- chrom_data[match(seqlevels(denyGR), chrom_data$chrom), ]
      # Check if chromosome order is the same
      if (!all.equal(seqlevels(denyGR), chrom_data$chrom)) {
        print(paste("Chromosome order does not match for", genome_id, "genome."))
        break
      }
      # Assign seqinfo data
      seqlengths(denyGR) <- chrom_data$size
      isCircular(denyGR) <- ifelse(is.na(chrom_data$circular), FALSE, TRUE)
      genome(denyGR)     <- "T2T-CHM13v2.0"
    } else if (genome_id == "TAIR10") {
      # Seqinfo for TAIR10 genome
      chrom_data <- GenomeInfoDb::getChromInfoFromNCBI(assembly = "TAIR10", assembled.molecules.only = TRUE)
      chrom_data$AssignedMolecule <- as.character(paste0("chr", chrom_data$AssignedMolecule)) # GCA_000001735.1
      # Make the same format as UCSC chromosome data
      chrom_data <- data.frame(chrom = chrom_data$AssignedMolecule,
                               size = chrom_data$SequenceLength,
                               assembled = ifelse(chrom_data$AssemblyUnit == "Primary Assembly", TRUE, FALSE),
                               circular = chrom_data$circular)
      # Keep standard chromosomes
      chromosomes_standard <- chrom_data$chrom
      # Subset and match to chromosomes in the denyGR object
      # Common chromosomes
      chromosomes_common <- intersect(chrom_data$chrom, seqlevels(denyGR))
      # Subset denyGR
      denyGR <- keepSeqlevels(denyGR, chromosomes_common, pruning.mode = "tidy")      
      # Subset chrom_data
      chrom_data <- chrom_data[chrom_data$chrom %in% chromosomes_common, ]
      # Match objects
      chrom_data <- chrom_data[match(seqlevels(denyGR), chrom_data$chrom), ]
      # Check if chromosome order is the same
      if (!all.equal(seqlevels(denyGR), chrom_data$chrom)) {
        print(paste("Chromosome order does not match for", genome_id, "genome."))
        break
      }
      # Assign seqinfo data
      seqlengths(denyGR) <- chrom_data$size
      isCircular(denyGR) <- ifelse(is.na(chrom_data$circular), FALSE, TRUE)
      genome(denyGR)     <- "TAIR10" # "GCA_000001735.1"
    } else {
      # Get chromosome info
      chrom_data <- GenomeInfoDb::getChromInfoFromUCSC(genome = genome_id, assembled.molecules.only = TRUE)
      # Exclude chrMT, only in hg19 genome
      chrom_data <- chrom_data[chrom_data$chrom != "chrMT", ]
      # Keep standard chromosomes
      chromosomes_standard <- chrom_data$chrom
      # Subset and match to chromosomes in the denyGR object
      # Common chromosomes
      chromosomes_common <- intersect(chrom_data$chrom, seqlevels(denyGR))
      # Subset denyGR
      denyGR <- keepSeqlevels(denyGR, chromosomes_common, pruning.mode = "tidy")      
      # Subset chrom_data
      chrom_data <- chrom_data[chrom_data$chrom %in% chromosomes_common, ]
      # Match objects
      chrom_data <- chrom_data[match(seqlevels(denyGR), chrom_data$chrom), ]
      # Check if chromosome order is the same
      if (!all.equal(seqlevels(denyGR), chrom_data$chrom)) {
        print(paste("Chromosome order does not match for", genome_id, "genome."))
        break
      }
      # Assign seqinfo data
      seqlengths(denyGR) <- chrom_data$size
      isCircular(denyGR) <- chrom_data$circular
      genome(denyGR)     <- genome_id
    }

    # Keep autosomes/sex/M chromosomes
    denyGR <- keepStandardChromosomes(x = denyGR, pruning.mode = "tidy")
    # Sort the object
    denyGR <- sort(denyGR)

    # Proceed only if non-empty. Note empty ones
    if (length(denyGR) == 0) {
      print(paste(mtx$Name[i], "is empty")) # Do nothing, just print
    } else {
      # Have a look inside
      print("GRanges object")
      print(denyGR)
      # Save the number of original regions
      counts_standard[i] <- length(denyGR)
      # Save missing chromosomes, if any
      chromosomes_missing[i] <- ifelse(length(setdiff(chromosomes_standard, seqlevels(denyGR))) == 0, "", paste(setdiff(chromosomes_standard, seqlevels(denyGR)), collapse = ", "))
      # Save width statistics
      width_min[i] <- min(width(denyGR))
      width_median[i] <- median(width(denyGR))
      width_max[i] <- max(width(denyGR))
      # Save percent genome covered
      fraction_genome[i] <- ( sum(width(denyGR)) / sum(chrom_data$size) ) 
      # If names are present, try to summarize
      if (!is.null(denyGR$name)) {
        names_unique <- table(denyGR$name)
        # If too long, print a few first
        if (length(names_unique) > 10) {
          print(names_unique[1:min(10, length(denyGR))])
        } else {
          # Otherwise, print summary
          sort(names_unique, decreasing = TRUE) %>% print()
        }
      }
      # Process with saving objects
      # Save BED file
      export.bed(object = denyGR, con = fileNameOut2)
      # Save as Rds object
      saveRDS(object = denyGR, file = fileNameOut3)
      # excludeGR <- readRDS(file = fileNameOut3)
    }
  } else {
    print(paste("Skipped:", mtx$Name[i]))
  }
  print("==================================================================")
}
```

# Custom processing 

## danRer10.Yang.Supplemental_Table_19.ChIP-seq_black_list_in_the_zebrafish_genome

```{r}
i <- which(mtx$Name == "danRer10.Yang.Supplemental_Table_19.ChIP-seq_black_list_in_the_zebrafish_genome")

  print(paste("Processing", i, mtx$Name[i]))
    # Download URL
    URL <- mtx$`ID/URL`[i]
    # Keep formatted URL
    url_formatted[i] <- URL

    # Directly downloadable files have their own extension
    fileNameOut1 <- file.path(dir_results, paste0(mtx$Name[i], ".", tools::file_ext(mtx$`ID/URL`[i])))
    # BED output file name
    fileNameOut2 <- file.path(dir_results, "bed", paste0(mtx$Name[i], ".bed"))
    # RDS output file name
    fileNameOut3 <- file.path(dir_results, "rds", paste0(mtx$Name[i], ".rds"))
    
    # Download file, if doesn't exist
    if (!file.exists(fileNameOut1)) {
      download.file(URL, fileNameOut1)
      # Unzip
      unzip(fileNameOut1, files = c("Supplemental_Tables/Supplemental Table 19. ChIP-seq black list in the zebrafish genome.xlsx"), junkpaths = TRUE, exdir = dir_results)
    }
    # Have a look inside
    mtx_data <- read_xlsx(file.path(dir_results, "Supplemental Table 19. ChIP-seq black list in the zebrafish genome.xlsx"), col_names = FALSE)
    print("Original data")
    print(head(mtx_data))
    # Save as tab-separated for rtracklayer
    fileNameOut1 <- file.path(dir_results, paste0(mtx$Name[i], ".bed"))
    write_tsv(mtx_data, fileNameOut1, col_names = FALSE)
    # Save the number of original regions
    counts_original[i] <- nrow(mtx_data)

    # Read it into GenomicRanges object
    denyGR <- rtracklayer::import(con = fileNameOut1, format = "bed")

    # Genome abbreviation
    genome_id <- mtx$Assembly[i]
      # Get chromosome info
      chrom_data <- GenomeInfoDb::getChromInfoFromUCSC(genome = genome_id, assembled.molecules.only = TRUE)
       # Keep standard chromosomes
      chromosomes_standard <- chrom_data$chrom
      # Subset and match to chromosomes in the denyGR object
      # Common chromosomes
      chromosomes_common <- intersect(chrom_data$chrom, seqlevels(denyGR))
      # Subset denyGR
      denyGR <- keepSeqlevels(denyGR, chromosomes_common, pruning.mode = "tidy")      
      # Subset chrom_data
      chrom_data <- chrom_data[chrom_data$chrom %in% chromosomes_common, ]
      # Match objects
      chrom_data <- chrom_data[match(seqlevels(denyGR), chrom_data$chrom), ]
      # Check if chromosome order is the same
      if (!all.equal(seqlevels(denyGR), chrom_data$chrom)) {
        print(paste("Chromosome order does not match for", genome_id, "genome."))
        break
      }
      # Assign seqinfo data
      seqlengths(denyGR) <- chrom_data$size
      isCircular(denyGR) <- chrom_data$circular
      genome(denyGR)     <- genome_id
    
    # Keep autosomes/sex/M chromosomes
    denyGR <- keepStandardChromosomes(x = denyGR, pruning.mode = "tidy")
    # Sort the object
    denyGR <- sort(denyGR)

      # Have a look inside
      print("GRanges object")
      print(denyGR)
      # Save the number of original regions
      counts_standard[i] <- length(denyGR)
      # Save missing chromosomes
      chromosomes_missing[i] <- ifelse(length(setdiff(chromosomes_standard, seqlevels(denyGR))) == 0, "", paste(setdiff(chromosomes_standard, seqlevels(denyGR)), sep = ",") )
      # Save width statistics
      width_min[i] <- min(width(denyGR))
      width_median[i] <- median(width(denyGR))
      width_max[i] <- max(width(denyGR))
      # Save percent genome covered
      fraction_genome[i] <- ( sum(width(denyGR)) / sum(chrom_data$size) )
      # If names are present, try to summarize
      if (!is.null(denyGR$name)) {
        names_unique <- table(denyGR$name)
        # If too long, print a few first
        if (length(names_unique) > 10) {
          print(names_unique[1:min(10, length(denyGR))])
        } else {
          # Otherwise, print summary
          sort(names_unique, decreasing = TRUE) %>% print()
        }
      }
      # Process with saving objects
      # Save BED file
      export.bed(object = denyGR, con = fileNameOut2)
      # Save as Rds object
      saveRDS(object = denyGR, file = fileNameOut3)
      # excludeGR <- readRDS(file = fileNameOut3)
  print("==================================================================")
```

## T2T.excluderanges 

```{r}
i <- which(mtx$Name == "T2T.excluderanges")

  # Process each record
  print(paste("Processing", i, mtx$Name[i]))
    URL <- mtx$`ID/URL`[i]
    # Keep formatted URL
    url_formatted[i] <- URL

    # Excluderanges need to have ".bed.gz" extension
    fileNameOut1 <- file.path(dir_results, paste0(mtx$Name[i], ".bed.gz"))
    # BED output file name
    fileNameOut2 <- file.path(dir_results, "bed", paste0(mtx$Name[i], ".bed"))
    # RDS output file name
    fileNameOut3 <- file.path(dir_results, "rds", paste0(mtx$Name[i], ".rds"))
    
    # Have a look inside
    mtx_data <- read_tsv(fileNameOut1, col_names = FALSE)
    print("Original data")
    print(head(mtx_data))
    # Save the number of original regions
    counts_original[i] <- nrow(mtx_data)

    # Read it into GenomicRanges object
    denyGR <- rtracklayer::import(con = fileNameOut1, format = "bed")
    # seqlevels(denyGR) <- paste0("chr", seqlevels(denyGR))

    # Genome abbreviation
    genome_id <- mtx$Assembly[i]
    if (genome_id == "T2T") {
      # Seqinfo for T2T genome
      chrom_data <- GenomeInfoDb::getChromInfoFromNCBI(assembly = "T2T-CHM13v2.0", assembled.molecules.only = TRUE) # GCA_009914755.4
      chrom_data$AssignedMolecule <- as.character(paste0("chr", chrom_data$AssignedMolecule))
      # Make the same format as UCSC chromosome data
      chrom_data <- data.frame(chrom = chrom_data$AssignedMolecule,
                               size = chrom_data$SequenceLength,
                               assembled = ifelse(chrom_data$AssemblyUnit == "Primary Assembly", TRUE, FALSE),
                               circular = chrom_data$circular)
      # Keep standard chromosomes
      chromosomes_standard <- chrom_data$chrom
      # Subset and match to chromosomes in the denyGR object
      # Common chromosomes
      chromosomes_common <- intersect(chrom_data$chrom, seqlevels(denyGR))
      # Subset denyGR
      denyGR <- keepSeqlevels(denyGR, chromosomes_common, pruning.mode = "tidy")      
      # Subset chrom_data
      chrom_data <- chrom_data[chrom_data$chrom %in% chromosomes_common, ]
      # Match objects
      chrom_data <- chrom_data[match(seqlevels(denyGR), chrom_data$chrom), ]
      # Check if chromosome order is the same
      if (!all.equal(seqlevels(denyGR), chrom_data$chrom)) {
        print(paste("Chromosome order does not match for", genome_id, "genome."))
        break
      }
      # Assign seqinfo data
      seqlengths(denyGR) <- chrom_data$size
      isCircular(denyGR) <- ifelse(is.na(chrom_data$circular), FALSE, TRUE)
      genome(denyGR)     <- "T2T-CHM13v2.0" # "GCA_009914755.4"
    } 

    # Keep autosomes/sex/M chromosomes
    denyGR <- keepStandardChromosomes(x = denyGR, pruning.mode = "tidy")
    # Sort the object
    denyGR <- sort(denyGR)

    # Proceed only if non-empty. Note empty ones
    if (length(denyGR) == 0) {
      print(paste(mtx$Name[i], "is empty")) # Do nothing, just print
    } else {
      # Have a look inside
      print("GRanges object")
      print(denyGR)
      # Save the number of original regions
      counts_standard[i] <- length(denyGR)
      # Save missing chromosomes, if any
      chromosomes_missing[i] <- ifelse(length(setdiff(chromosomes_standard, seqlevels(denyGR))) == 0, "", paste(setdiff(chromosomes_standard, seqlevels(denyGR)), collapse = ", "))
      # Save width statistics
      width_min[i] <- min(width(denyGR))
      width_median[i] <- median(width(denyGR))
      width_max[i] <- max(width(denyGR))
      # Save percent genome covered
      fraction_genome[i] <- ( sum(width(denyGR)) / sum(chrom_data$size) ) 
      # If names are present, try to summarize
      if (!is.null(denyGR$name)) {
        names_unique <- table(denyGR$name)
        # If too long, print a few first
        if (length(names_unique) > 10) {
          print(names_unique[1:min(10, length(denyGR))])
        } else {
          # Otherwise, print summary
          sort(names_unique, decreasing = TRUE) %>% print()
        }
      }
      # Process with saving objects
      # Save BED file
      export.bed(object = denyGR, con = fileNameOut2)
      # Save as Rds object
      saveRDS(object = denyGR, file = fileNameOut3)
      # excludeGR <- readRDS(file = fileNameOut3)
    }
  print("==================================================================")
```

## mm39.excluderanges

```{r}
i <- which(mtx$Name == "mm39.excluderanges")

  # Process each record
  print(paste("Processing", i, mtx$Name[i]))
    URL <- mtx$`ID/URL`[i]
    # Keep formatted URL
    url_formatted[i] <- URL

    # Excluderanges need to have ".bed.gz" extension
    fileNameOut1 <- file.path(dir_results, paste0(mtx$Name[i], ".bed.gz"))
    # BED output file name
    fileNameOut2 <- file.path(dir_results, "bed", paste0(mtx$Name[i], ".bed"))
    # RDS output file name
    fileNameOut3 <- file.path(dir_results, "rds", paste0(mtx$Name[i], ".rds"))
    
    # Have a look inside
    mtx_data <- read_tsv(fileNameOut1, col_names = FALSE)
    print("Original data")
    print(head(mtx_data))
    # Save the number of original regions
    counts_original[i] <- nrow(mtx_data)

    # Read it into GenomicRanges object
    denyGR <- rtracklayer::import(con = fileNameOut1, format = "bed")

    # Genome abbreviation
    genome_id <- mtx$Assembly[i]
      # Get chromosome info
      chrom_data <- GenomeInfoDb::getChromInfoFromUCSC(genome = genome_id, assembled.molecules.only = TRUE)
      # Keep standard chromosomes
      chromosomes_standard <- chrom_data$chrom
      # Subset and match to chromosomes in the denyGR object
      # Common chromosomes
      chromosomes_common <- intersect(chrom_data$chrom, seqlevels(denyGR))
      # Subset denyGR
      denyGR <- keepSeqlevels(denyGR, chromosomes_common, pruning.mode = "tidy")      
      # Subset chrom_data
      chrom_data <- chrom_data[chrom_data$chrom %in% chromosomes_common, ]
      # Match objects
      chrom_data <- chrom_data[match(seqlevels(denyGR), chrom_data$chrom), ]
      # Check if chromosome order is the same
      if (!all.equal(seqlevels(denyGR), chrom_data$chrom)) {
        print(paste("Chromosome order does not match for", genome_id, "genome."))
        break
      }
      # Assign seqinfo data
      seqlengths(denyGR) <- chrom_data$size
      isCircular(denyGR) <- chrom_data$circular
      genome(denyGR)     <- genome_id

    # Keep autosomes/sex/M chromosomes
    denyGR <- keepStandardChromosomes(x = denyGR, pruning.mode = "tidy")
    # Sort the object
    denyGR <- sort(denyGR)

    # Proceed only if non-empty. Note empty ones
    if (length(denyGR) == 0) {
      print(paste(mtx$Name[i], "is empty")) # Do nothing, just print
    } else {
      # Have a look inside
      print("GRanges object")
      print(denyGR)
      # Save the number of original regions
      counts_standard[i] <- length(denyGR)
      # Save missing chromosomes, if any
      chromosomes_missing[i] <- ifelse(length(setdiff(chromosomes_standard, seqlevels(denyGR))) == 0, "", paste(setdiff(chromosomes_standard, seqlevels(denyGR)), collapse = ", "))
      # Save width statistics
      width_min[i] <- min(width(denyGR))
      width_median[i] <- median(width(denyGR))
      width_max[i] <- max(width(denyGR))
      # Save percent genome covered
      fraction_genome[i] <- ( sum(width(denyGR)) / sum(chrom_data$size) ) 
      # If names are present, try to summarize
      if (!is.null(denyGR$name)) {
        names_unique <- table(denyGR$name)
        # If too long, print a few first
        if (length(names_unique) > 10) {
          print(names_unique[1:min(10, length(denyGR))])
        } else {
          # Otherwise, print summary
          sort(names_unique, decreasing = TRUE) %>% print()
        }
      }
      # Process with saving objects
      # Save BED file
      export.bed(object = denyGR, con = fileNameOut2)
      # Save as Rds object
      saveRDS(object = denyGR, file = fileNameOut3)
      # excludeGR <- readRDS(file = fileNameOut3)
    }
  print("==================================================================")
```

# Processing summary

```{r}
mtx_summary <- data.frame(Name = mtx$Name, 
                          Assembly = mtx$Assembly,
                          Description = mtx$Description,
                          `Original Region count` = counts_original, 
                          `Filtered Range count` = counts_standard,
                          `Missing Chromosomes` = chromosomes_missing,
                          `Width, min/median/max, bp` = paste(formatC(width_min, format = "f", digits = 0), formatC(width_median, format = "f", digits = 0), formatC(width_max, format = "f", digits = 0), sep = "/"),
                          `Percent of the genome, %` = formatC(fraction_genome * 100, format = "f", digits = 4),
                          `Year last updated` = mtx$`Year last updated`,
                          Source = mtx$Source,
                          `ID/URL` = mtx$`ID/URL`)# pander(mtx_summary)
# Save the data
write_csv(mtx_summary, file = fileNameOutSummary)
```


```{r eval=FALSE}
# Exploring chromosome annotation data
# C elegans chromosomes
chrom_data <- GenomeInfoDb::getChromInfoFromUCSC(genome = "ce10")
chrom_data
# Drosophila chromosomes
chrom_data <- GenomeInfoDb::getChromInfoFromUCSC(genome = "dm6")
chrom_data
```



